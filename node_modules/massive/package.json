{
  "name": "massive",
  "description": "Sequel-ish db utility for Node",
  "version": "0.1.3",
  "author": {
    "name": "Rob Conery",
    "email": "rob@tekpub.com"
  },
  "contributors": [
    {
      "name": "Karl Seguin",
      "email": "karl@openmymind.net"
    }
  ],
  "dependencies": {
    "pg": "0.6.17",
    "mysql": "0.9.5",
    "underscore": "1.3.3"
  },
  "devDependencies": {
    "mocha": "1.0.3",
    "coffee-script": "1.2.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/robconery/massive.git"
  },
  "keywords": [
    "database",
    "query",
    "postgres",
    "sequel",
    "mysql"
  ],
  "main": "./lib/index.js",
  "engines": {
    "node": ">= 0.5.0"
  },
  "readme": "## Some Light Abstraction for Accessing Data\n\nMassive is a data access tool for Node JS that works with relational data systems - currently Postgres and MySQL.\n\nMassive's goal is to **help** you get data from your database. This is not an ORM, it's a bit more than a query tool - our goal is to do just enough, then get out of your way. I happen to love Sequel (the Ruby data access tool) and I've emulated that tool ... sort of... with Massive.\n\n## The 5-Second Hi How Are Ya\n\nInstallation is the usual:\n\n```\nnpm install massive\n```\n\nTo work with Massive, create a connection do something interesting:\n\n```javascript\nvar db = require(\"massive\");\ndb.connect(\"postgres://postgres@localhost/mydatabase\", function(err, db){\n  db.myTable.each(function(thing){\n    console.log(thing);\n  });\n});\n```\n\nYou open a connection against a database (currently Postgres or MySQL) and Massive will snoop your tables using Information.Schema, and will magically \"bind\" those tables as properties to your db for querying:\n\n```javascript\ndb.myTable.find({id : 1}).execute(function(err, thing) {\n  console.log(thing);\n});\n```\n\nSometimes having all your columns returned to you isn't optimal:\n\n```javascript\ndb.myTable.find({id : 1}, {columns : \"name\"}).execute(function(err, thing) {\n  console.log(thing.name);\n});\n```\n\nIf you pass a column list in to find, as an array, it works too:\n\n```javascript\ndb.myTable.find([\"name\"]).execute(function(err, thing) {\n  console.log(thing.name);\n});\n```\n\n\nMassive is highly-evented, which means you can work with events rather than callbacks:\n\n```javascript\nvar allMyStuff = db.myTable.find({\"id > \" : 0});\nallMyStuff.on(\"row\", function(row){\n  console.log(row);\n});\n\n```\n\nBy adding the \"row\" event, the query is triggered and you can then iterate over it. You could also use \"each()\" as above, and it would do the same thing. You can also listen for when the iteration is completed:\n\n```javascript\nvar allMyStuff = db.myTable.find({\"id > \" : 0});\nallMyStuff.each(function(thing){\n  console.log(thing);\n});\n\nallMyStuff.on(\"end\", function(){\n  console.log(\"Guess that's all!\")\n});\n\n```\n\nOne other event that is very handy is \"executed\" - this tells you when a query has completed. This works pretty nicely with the way inserts work:\n\n```javascript\nvar newProduct = db.products.insert({name : \"vanilla soda\", price : 100});\nnewProduct.on(\"executed\", db.featuredProducts.insert);\nnewProduct.execute();\n```\n\nQueries in Massive are independent of their execution and are little Event Vehicles (a word I made up). In this example I created a query and wired another query to go off when execution is completed. Massive \"forwards\" the data to any listeners on the event (in this case it's a new product record). Node then uses that bit of data as an argument to pass into the db.featuredProducts table.\n\nYou can add, edit, and delete records - which I'll show in a second - but the ultimate thing to remember is you can **always use SQL** when you need to:\n\n```javascript\ndb.run(\"select message from freakytable where id = $1\", [\"la la la\"], function(err, result){\n  console.log(\"Freaky! \" + result)\n});\n```\n\nI like SQL and I find that by staying true to SQL rather than muscling an ORM abstraction makes life much happier. Now, on to the rest of the stuff...\n\n## Inserts\n\nInserting data into your database is pretty straightforward:\n\n```javascript\ndb.myTable.insert({name:\"rubber ducky\", message : \"You're the one\"}).execute(function(err,result){\n  //if you're using Postgres, the new record is returned\n  console.log(\"The new id is \" + result.id);\n});\n```\n\nMany times you need to insert a whole bunch of stuff:\n\n```javascript\nvar items = [\n  {name:\"stuffy stuff\", price: 12.00},\n  {name:\"poofy poof\", price: 24.00}\n];\ndb.myFluffyAnimals.insert(items).execute(function(err,newGuys){\n  _.each(newGuys, function(err,newGuy){\n    console.log(\"Hello there \" + newGuy.name);\n  });\n});\n```\n\nHere I'm using Underscore.js's \"each\" method to roll out an array of results - all of the critters are inserted as part of a single statement, rather than one at a time.\n\n## Updates\n\nUpdates follow the same pattern:\n\n```javascript\ndb.myFluffyAnimals.update({name : \"crunchy crunch\"}, 2).execute(function(err,result){\n  console.log(\"Price updated!\");\n});\n\n```\n\nThis example used a single record, but you can also update more than one record:\n\n```javascript\ndb.myFluffyAnimals.update({name : \"crunchy crunch\"}, {\"id <>\" : 100}).execute(function(err,result){\n  console.log(\"Price updated!\");\n});\n\n```\n\n## Limits, Orders, etc\n\nYou can order and limit your query using a bit of a fluent interface:\n\n```javascript\nvar moreThanAHundo = db.myFluffyAnimals.find({\"price < \": 100}).order(\"name\").limit(10);\nmoreThanAHundo.each(function(critter){\n  console.log(\"Ahoy!\")\n});\n\n```\n\nThis example uses a few new things: the `each` method on the query and the order/limit stuff in a fluent fashion. It also uses a nice readable criteria set where the operator is a string key that gets sent in.\n\n## Deletes\n\nDeletes are a sad thing, but often are required:\n\n```javascript\ndb.myFluffyAnimals.destroy().execute(function(){\n  console.log(\"All gone :(\")\n});\n```\n\nOf course, that's a bit drastic. Let's just delete a few:\n\n```javascript\ndb.myFluffyAnimals.destroy({\"price > \" : 1000}).execute(function(){\n  console.log(\"Expensive stuff - OUTTA HERE\");\n});\n```\n\nOr maybe just one?\n\n```javascript\ndb.myFluffyAnimals.destroy(1).execute(function(){\n  console.log(\"The first critter is toast\");\n});\n```\n\n## Schema\n\nNo self-respecting data tool would leave you without the ability to create a table!\n\n```javascript\n//a query, just like the other stuff\nvar sparklyCritters = db.createTable(\"sparkly_stuff\", {\n    name : 'string not null',\n    price : 'money',\n    birthday : 'date',\n    ip : 'inet not null default '127.0.0.1'\n});\n\nsparklyCritters.execute();\n```\n\nNo, \"string\", \"money\" and \"date\" aren't valid Postgres types (well date sorta is). These are transformed by Massive into \"varchar(255)\", \"decimal(8,2)\", and \"timestamptz\" for you.\n\nThe last entry is an IP address - and notice you can send in whatever you like. Massive will try and digest it.\n\n## Examples\n\nThere's an examples directory that shows more goodies, and our tests also give a nice indication of what's possible.\n\n## Want to help?\n\nThis is my first Node module and I'm just getting my juices flowing with Javascript. It's highly-likely that I forgot a semi-colon or maybe did something dumb. If you spot something and want to help me - yay! Please be sure to let me know why what you're doing is better so we can all learn.\n\nIf you see a bug, please be so kind as to show how it's failing, and I'll do my best to get it fixed quickly.\n\n\n\n\n",
  "readmeFilename": "README.md",
  "_id": "massive@0.1.3",
  "dist": {
    "shasum": "0cfc84784fb79be82e9ac5078c13ab61026fb8e5"
  },
  "_from": "massive"
}
